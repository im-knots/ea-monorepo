<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eru Labs</title>
  <style>
    #logo-container {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1000; /* Ensures it stays above other elements */
    }

    #logo {
        max-width: 300px; /* Adjust size as needed */
        height: auto;
        display: block;
    }
    /********************************************
     * Page + Container Setup
     ********************************************/
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      font-family: monospace;
      overflow: hidden; /* Hide scrollbars */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /********************************************
     * 1) Terminal
     ********************************************/
    #terminal-container {
      position: relative;
      z-index: 2;
      width: 300px;
      text-align: left;
      text-shadow:
        0 0 5px #0f0,
        0 0 10px #0f0,
        0 0 20px #0f0; 
      font-size: 1.2rem;
      line-height: 1.5;
      color: #0f0; 
      white-space: pre;
      transition: opacity 1s ease; /* Fade-out transition */
    }
    .cursor {
      display: inline-block;
      width: 9px;
      height: 1em;
      vertical-align: baseline;
      background-color: #0f0;
      box-shadow:
        0 0 5px #0f0,
        0 0 10px #0f0,
        0 0 20px #0f0;
      animation: blink 0.8s steps(1) infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }

    /********************************************
     * 2) Starfield (Hyperspace)
     ********************************************/
    #star-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background-color: #000;
      opacity: 0; /* Start invisible, we'll fade it in */
      transition: opacity 1s ease;
    }

    /********************************************
     * 3) Network of Nodes
     ********************************************/
    #network-container {
      position: absolute;
      top: 0; left: 0;
      width: 100%; 
      height: 100%;
      z-index: 3;
      background-color: #000;
      display: none; /* Hidden initially; we show it after starfield ends */
      overflow: hidden; /* keep it neat */
      opacity: 0; 
      transition: opacity 1s ease;
    }

    #network-svg {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
    }

    /* Main node styling (white with white glow) */
    .node {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 40px;
      background: #fff;     
      box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #000;          
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      text-align: center;
      transition: transform 0.2s;
    }
    .node:hover {
      transform: scale(1.1);
    }

    /* Sub-node styling: smaller, maybe a faint glow */
    .sub-node {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 10px;
      background: #ffffff;  /* or some other color */
      box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff;
      cursor: default;   /* Typically not clickable, but you can change */
    }
  </style>
</head>
<body>
  <!-- Logo -->
  <div id="logo-container">
    <img src="img/logo.png" alt="Eru Labs Logo" id="logo">
  </div>

  <!-- Terminal container -->
  <div id="terminal-container">
    <span id="typed-text-container"></span>
  </div>

  <!-- Starfield Canvas -->
  <canvas id="star-canvas"></canvas>

  <!-- Network of Nodes -->
  <div id="network-container">
    <svg id="network-svg">
      <defs>
        <filter id="line-glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur"/>
          <feMerge>
            <feMergeNode in="blur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
    </svg>
  </div>

<script>
/***************************************************************
 * STEP 1: TERMINAL TYPING
 ***************************************************************/
let typedSoFar = "$ "; // Start with "$ "
const lines = [
  { text: "./erulabs.ai", delayPerChar: 100 },
  { text: "\n    loading eru........ DONE", delayPerChar: 100 },
  { text: "\n    starting ainulindale................. DONE ", delayPerChar: 100 },
  { text: "\n    launching Ea ................... DONE ", delayPerChar: 100 }
];

let currentLineIndex = 0;
let charIndex = 0;

const typedTextContainer = document.getElementById("typed-text-container");
const terminalContainer = document.getElementById("terminal-container");

function createCursor() {
  const c = document.createElement("span");
  c.className = "cursor";
  return c;
}

function typeNextCharacter() {
  // Remove old cursor
  const oldCursor = typedTextContainer.querySelector(".cursor");
  if (oldCursor) oldCursor.remove();

  const line = lines[currentLineIndex];
  if (!line) return;

  if (charIndex < line.text.length) {
    typedSoFar += line.text.charAt(charIndex);
    charIndex++;
    typedTextContainer.textContent = typedSoFar;
    typedTextContainer.appendChild(createCursor());
    setTimeout(typeNextCharacter, line.delayPerChar);
  } else {
    // Done with this line
    typedTextContainer.textContent = typedSoFar;
    currentLineIndex++;
    charIndex = 0;

    if (currentLineIndex < lines.length) {
      setTimeout(typeNextCharacter, 700);
    } else {
      // All lines done -> final cursor
      typedTextContainer.appendChild(createCursor());

      // Fade out terminal after a short pause, then start starfield
      setTimeout(() => {
        terminalContainer.style.opacity = 0;
        setTimeout(startHyperspace, 1200); 
      }, 1000);
    }
  }
}
// Start typing after 500 ms
setTimeout(typeNextCharacter, 500);


/***************************************************************
 * STEP 2: HYPERSPACE STARFIELD
 ***************************************************************/
const starCanvas = document.getElementById("star-canvas");
const ctx = starCanvas.getContext("2d");
let stars = [];
let isHyperspaceActive = false;
let starAnimationFrame;

function resizeCanvas() {
  starCanvas.width = window.innerWidth;
  starCanvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

class Star {
  constructor() {
    this.x = starCanvas.width / 2;
    this.y = starCanvas.height / 2;
    this.angle = Math.random() * 2 * Math.PI;
    this.speed = 2 + Math.random() * 5;
    this.size = 2;
  }
  update() {
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    this.speed *= 1.03; // accelerate
  }
  draw() {
    ctx.fillStyle = "white";
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }
}

function createStars(count) {
  for (let i = 0; i < count; i++) {
    stars.push(new Star());
  }
}

function animateStars() {
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.fillRect(0, 0, starCanvas.width, starCanvas.height);

  for (let i = 0; i < stars.length; i++) {
    const s = stars[i];
    s.update();
    s.draw();
    // if star goes offscreen, reset
    if (
      s.x < 0 || s.x > starCanvas.width ||
      s.y < 0 || s.y > starCanvas.height
    ) {
      stars[i] = new Star();
    }
  }

  if (isHyperspaceActive) {
    starAnimationFrame = requestAnimationFrame(animateStars);
  }
}

// Called once terminal is faded out
function startHyperspace() {
  // Show star canvas, fade it in
  starCanvas.style.opacity = 1;

  isHyperspaceActive = true;
  createStars(200);
  animateStars();

  // After ~5 seconds, fade out starfield & show network
  setTimeout(() => {
    starCanvas.style.opacity = 0;
    isHyperspaceActive = false; 
    cancelAnimationFrame(starAnimationFrame);
    setTimeout(showNetwork, 1200); 
  }, 5000);
}


/***************************************************************
 * STEP 3: NETWORK (Main Nodes + Sub-nodes) with MOUSE GRAVITY
 ***************************************************************/
 const networkContainer = document.getElementById("network-container");
const networkSvg = document.getElementById("network-svg");

const friction = 0.25;    // how quickly velocity decays each frame
const minSpeed = 0.1;     // clamp speeds to avoid “stuck” or super slow
const maxSpeed = 150;       // clamp speeds to avoid extreme speeds
const spawnInterval = 5000; // ms between sub-node spawns
const maxSubs = 50;      // max sub-nodes per main node

/** 
 * We'll define 5 "main" nodes, each can spawn up to 50 sub-nodes. 
 * mainNodes and subNodes store data about positions, velocities, etc.
 */
const mainNodeData = [
  { label: "Coming Soon",    link: "about.html" }
];

let mainNodes = [];      // Each item: { x, y, vx, vy, element, subCount }
let subNodes = [];       // Each item: { parentIndex, x, y, vx, vy, element }

/** Mouse for gravity */
let mouse = {
  x: 0,
  y: 0,
  pressed: false
};

function showNetwork() {
  networkContainer.style.display = "block";
  setTimeout(() => {
    networkContainer.style.opacity = 1;
  }, 50);

  // Create main nodes
  mainNodeData.forEach((data, i) => {
    const nodeEl = document.createElement("div");
    nodeEl.classList.add("node");
    nodeEl.textContent = data.label;

    const x = Math.random() * (window.innerWidth - 100);
    const y = Math.random() * (window.innerHeight - 100);
    const vx = (Math.random() - 0.5) * 0.5;
    const vy = (Math.random() - 0.5) * 0.5;

    networkContainer.appendChild(nodeEl);

    mainNodes.push({
      x, y, vx, vy,
      element: nodeEl,
      subCount: 0
    });

    nodeEl.addEventListener("click", () => {
      console.log("Clicked node =>", data.link);
    });
  });

  networkContainer.addEventListener("mousedown", () => { mouse.pressed = true; });
  window.addEventListener("mouseup",   () => { mouse.pressed = false; });
  networkContainer.addEventListener("mousemove", (e) => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  setInterval(spawnSingleSubNode, spawnInterval); // Spawn sub-node for one main node
  requestAnimationFrame(updateNetwork);
}

/** Spawn a sub-node for a random main node, if not at maxSubs. */
function spawnSingleSubNode() {
  const randomIndex = Math.floor(Math.random() * mainNodes.length);
  const node = mainNodes[randomIndex];
  if (node.subCount < maxSubs) {
    createSubNode(randomIndex);
    node.subCount++;
  }
}

/** Create a sub-node near a given main node index. */
function createSubNode(parentIndex) {
  const parent = mainNodes[parentIndex];
  const x = parent.x + (Math.random() - 0.5) * 60;
  const y = parent.y + (Math.random() - 0.5) * 60;
  const vx = (Math.random() - 0.5) * 0.5;
  const vy = (Math.random() - 0.5) * 0.5;

  const el = document.createElement("div");
  el.className = "sub-node";
  networkContainer.appendChild(el);

  subNodes.push({
    parentIndex,
    x, y, vx, vy,
    element: el
  });
}

function updateNetwork() {
  for (let i = 0; i < mainNodes.length; i++) {
    let { x, y, vx, vy, element } = mainNodes[i];

    if (mouse.pressed) {
      const dx = mouse.x - x;
      const dy = mouse.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let force = 1000 / (dist * dist);
      if (force > 700.0) force = 700.0;
      vx += force * (dx / dist);
      vy += force * (dy / dist);
    }

    x += vx;
    y += vy;

    if (x < 0 || x > window.innerWidth - 80) vx = -vx;
    if (y < 0 || y > window.innerHeight - 80) vy = -vy;

    ({ vx, vy } = applyFrictionAndClamp(vx, vy));

    mainNodes[i].x = x;
    mainNodes[i].y = y;
    mainNodes[i].vx = vx;
    mainNodes[i].vy = vy;

    element.style.left = x + "px";
    element.style.top = y + "px";
  }

  for (let i = 0; i < subNodes.length; i++) {
    let { parentIndex, x, y, vx, vy, element } = subNodes[i];

    const parent = mainNodes[parentIndex];
    const dx = x - parent.x;
    const dy = y - parent.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;

    if (dist < 60) {
      vx += dx / dist * 0.5; // Bounce off main node
      vy += dy / dist * 0.5;
    }

    x += vx;
    y += vy;

    if (x < 0 || x > window.innerWidth - 20) vx = -vx;
    if (y < 0 || y > window.innerHeight - 20) vy = -vy;

    ({ vx, vy } = applyFrictionAndClamp(vx, vy));

    subNodes[i].x = x;
    subNodes[i].y = y;
    subNodes[i].vx = vx;
    subNodes[i].vy = vy;

    element.style.left = x + "px";
    element.style.top = y + "px";
  }

  drawLines();
  requestAnimationFrame(updateNetwork);
}

function drawLines() {
  while (networkSvg.firstChild) {
    networkSvg.removeChild(networkSvg.firstChild);
  }

  for (let i = 0; i < mainNodes.length; i++) {
    const x1 = mainNodes[i].x + 40;
    const y1 = mainNodes[i].y + 40;
    for (let j = i + 1; j < mainNodes.length; j++) {
      const x2 = mainNodes[j].x + 40;
      const y2 = mainNodes[j].y + 40;
      drawLine(x1, y1, x2, y2); // Connect main nodes
    }
  }

  for (let i = 0; i < subNodes.length; i++) {
    const sub = subNodes[i];
    const neighbors = findNearestNeighbors(i, 3); // Find nearest neighbors
    if (neighbors.length === 0) {
      const parent = mainNodes[sub.parentIndex];
      drawLine(sub.x + 10, sub.y + 10, parent.x + 40, parent.y + 40);
    } else {
      neighbors.forEach(j => {
        drawLine(sub.x + 10, sub.y + 10, subNodes[j].x + 10, subNodes[j].y + 10);
      });
    }
  }
}

/** Find the nearest n neighbors of a sub-node. */
function findNearestNeighbors(index, n) {
  const sub = subNodes[index];
  const distances = subNodes.map((other, i) => {
    if (i === index) return Infinity;
    const dx = sub.x - other.x;
    const dy = sub.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  });
  return distances
    .map((dist, i) => ({ dist, i }))
    .sort((a, b) => a.dist - b.dist)
    .slice(0, n)
    .map(obj => obj.i);
}

function drawLine(x1, y1, x2, y2) {
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", x1);
  line.setAttribute("y1", y1);
  line.setAttribute("x2", x2);
  line.setAttribute("y2", y2);
  line.setAttribute("stroke", "#fff");
  line.setAttribute("stroke-width", "2");
  line.setAttribute("stroke-linecap", "round");
  line.setAttribute("stroke-linejoin", "round");
  line.setAttribute("filter", "url(#line-glow)");
  networkSvg.appendChild(line);
}

function applyFrictionAndClamp(vx, vy) {
  vx *= friction;
  vy *= friction;

  const speed = Math.sqrt(vx * vx + vy * vy);
  if (speed > maxSpeed) {
    vx = (vx / speed) * maxSpeed;
    vy = (vy / speed) * maxSpeed;
  } else if (speed > 0 && speed < minSpeed) {
    vx = (vx / speed) * minSpeed;
    vy = (vy / speed) * minSpeed;
  }
  return { vx, vy };
}



</script>
</body>
</html>
